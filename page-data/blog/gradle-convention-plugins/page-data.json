{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/gradle-convention-plugins/","result":{"data":{"site":{"siteMetadata":{"title":"Anton Danshin"}},"markdownRemark":{"id":"8b4e60c2-2e47-548e-8d3c-b215c7998e90","excerpt":"Many Android projects contain more than one module (subproject). In a product oriented project, it will be one app module and many library modules. When the…","html":"<p>Many Android projects contain more than one module (subproject). In a product oriented project, it will be one app module and many library modules. When the team is developing white-label apps, it will be many apps on top of many library modules.</p>\n<p>Here is what I often see in our project. When creating a new module, some developers would use Android Studio GUI and then adjust it according to what they need. Others would simply copy-paste some existing module and change it. Some people would even write build configuration from scratch. Generally, there is nothing wrong with this. Bu over time, this practice had caused us several issues:</p>\n<ul>\n<li><strong>Inconsistencies.</strong> Build configuration might differ from module to module (e.g., could have different <code class=\"language-text\">compileSdkVersion</code>).</li>\n<li><strong>Poor maintainability.</strong> If we need to apply some new setting to all modules, we will have to change them all.</li>\n<li><strong>Redundant logic.</strong> Build configuration may contain redundant parameters / code, developers are afraid to remove it to break something.</li>\n</ul>\n<p>Since we are making wite-labels apps, we have created a script that automates some of the copy-paste we have to do in order to bootstrap the boilerplate for new apps. The amount of duplication in the build logic grows even faster.</p>\n<h2>Sharing external dependencies and versions accross Gradle modules</h2>\n<p>One of the common things developers do, is introducing constants for external libraries. In many projects I see on Github, all versions and library locators are placed to <code class=\"language-text\">versions.gradle</code> in the project’s root directory. The file typically declares version of different libraries and plugins, and also groups all libraries by vendor Then, all the versions and dependencse are placed into Gradle’s <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\">ExtraPropertiesExtension</a>, aka <code class=\"language-text\">ext</code>.</p>\n<blockquote>\n<p>I’ve heard that using <code class=\"language-text\">ext</code> to keep common parameters across subprojects is not a very good practice. I don’t know why exactly… I could certainly find some of its drawbacks if I try. However, our project is currenly using this approach.</p>\n</blockquote>\n<p>Gradle team noticed the trend and came up with a solution called <a href=\"https://docs.gradle.org/current/userguide/platforms.html\">Version Catalogs</a>, which is currently a feature preview. The feature allows you to define versions and libraries in a <code class=\"language-text\">*.toml</code> file. Gradle will generate type-safe accessors based on the declarations in the file.</p>\n<p>You could try using it for new projects. However, if you already have your own “version catalog” that works for you, I don’t really see a need to migrate to the Gradle solution. Compared to defining versions in a Gradle or Kotlin script with IDE support, I found it quite annoying that you have to edit <code class=\"language-text\">*.toml</code>. Apart from syntax highlighing, IDE doesn’t help you with the code completion (at least as of the time of writing this post there was an <a href=\"https://youtrack.jetbrains.com/issue/IDEA-262280\">open issue</a> about that), and you can easily mess it up.</p>\n<h2>Sharing common build logic accross Gradle modules</h2>\n<p>Common pattern that people do here, is either putting the code into <code class=\"language-text\">subprojects {}</code> block of root <code class=\"language-text\">build.gradle</code> file, or put configuration logic into a separate gradle file and apply it to specific module via <code class=\"language-text\">apply from: 'file.gradle'</code>.</p>\n<p>This is a solution, but because you cannot often split root <code class=\"language-text\">build.gradle</code> into separate files, the file becomes inflated. This also causes subprojects to implicitly <strong>rely</strong> on configuration logic written in the root <code class=\"language-text\">build.gradle</code>.</p>\n<p>Fortunately, now there is an easy way split the common build logic into separate gradle files (plugins) that also make subprojects explicitely declare that they are using this configuration. This approach is based on a Gradle feature <a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html#sec:precompiled_plugins\">Precompiled Script Plugins</a> and this is now a recommend way for sharing build logic accorss modules in larger projects. Such precompiled plugins that contain pieces of shared build logic are often referred to as <em>Convention plugins</em>.</p>\n<p>If you don’t have many modules, I think it still OK writing your common build logic the old way. But as project grows, you may not notice how your 10 modules became 30, and 30 become 50… So, why not invest a little bit of time and set up a future proof structure at the early?</p>\n<blockquote>\n<p>Before applying it to your project, always check whether the benefits that the convention plugins bring outweigh the drawbacks (e.g. potentially slower build or some other issue).</p>\n</blockquote>\n<p><strong>The benefits</strong> of using convention plugins are:</p>\n<ol>\n<li>Just like with <code class=\"language-text\">subprojects { }</code> configuration block, you will be able to extract common logic in one place.</li>\n<li>You will be able separate common logic into completely independent bits, which should be easier to maintain.</li>\n<li>You explicitly apply different convention plugins to different modules.</li>\n</ol>\n<blockquote>\n<p>By the way! It is possible to migrate to the new approach slowly. I am currently implementing it in our project and have only applied the plugins to a subset of modules. Seems to be working fine.</p>\n</blockquote>\n<p><strong>The drawbacks</strong> that I noticed are:</p>\n<ol>\n<li>It requires you to use newer Gradle, as well as new <code class=\"language-text\">pluginManagement {}</code>, which has some issues when used together with the older <code class=\"language-text\">builscript</code>. Ideally, all projects should migrate to new approach.</li>\n<li>It will take a little extra time to compile included build.</li>\n<li>This is not the default way, so when you introduce new team members to the project, they will have to learn your new “conventions”.</li>\n</ol>\n<h2>How to add simple convention plugin</h2>\n<p>Convention plugins are placed into an <a href=\"https://docs.gradle.org/current/userguide/composite_builds.html\">included build</a>.</p>\n<p>The idea is to put all your build logic into special project, which you can call <code class=\"language-text\">build-logic</code>. It is going to be a standalone gradle project, with its own <code class=\"language-text\">settings.gradle</code> and <code class=\"language-text\">build.gradle</code> scripts and submodules. It can then be declared as an included build in root project’s <code class=\"language-text\">settings.gradle</code>. Alternatively, it can also be included at build time via command line parameter: <code class=\"language-text\">./gradlew --include-build build-logic</code>.</p>\n<h3>Project structure</h3>\n<p>Here is how the project structure would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"plaintext\"><pre class=\"language-plaintext\"><code class=\"language-plaintext\">root-project\n├── build.gradle\n├── gradle.properties\n├── settings.gradle\n├── build-logic\n│   ├── build.gradle.kts\n│   ├── convention-plugins\n│   │   ├── build.gradle.kts\n│   │   └── src\n│   └── settings.gradle.kts\n├── app\n│   ├── build.gradle\n│   └── src\n└── library-module\n    ├── build.gradle\n    └── src</code></pre></div>\n<h3>Root project config</h3>\n<p>In root-project’s <code class=\"language-text\">build.gradle</code> we need to add the following lines:</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">pluginManagement <span class=\"token punctuation\">{</span>\n    repositories <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">gradlePluginPortal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">google</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">includeBuild</span><span class=\"token punctuation\">(</span><span class=\"token string\">'build-logic'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<blockquote>\n<p>The <code class=\"language-text\">pluginManagement</code> block is important. Without it convention plugins won’t work.</p>\n</blockquote>\n<p>There is an <a href=\"https://youtrack.jetbrains.com/issue/IDEA-262528\">issue</a> with IDEA that causes wrong gradle wrapper to be used when running tests from IDE. It can be fixed by setting version of Gradle Wrapper in the root <code class=\"language-text\">build.gradle</code> script:</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">tasks<span class=\"token punctuation\">.</span><span class=\"token function\">withType</span><span class=\"token punctuation\">(</span>Wrapper<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>configureEach <span class=\"token punctuation\">{</span>\n    distributionType <span class=\"token operator\">=</span> Wrapper<span class=\"token punctuation\">.</span>DistributionType<span class=\"token punctuation\">.</span>BIN\n    gradleVersion <span class=\"token operator\">=</span> <span class=\"token interpolation-string\"><span class=\"token string\">\"7.3.1\"</span></span> <span class=\"token comment\">// set the same version as in gradle/wrapper/gradle-wrapper.properties</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Included build: build-logic</h3>\n<p>In the <code class=\"language-text\">build-logic/settings.gradle.kts</code> you should have the following lines:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">pluginManagement <span class=\"token punctuation\">{</span>\n    repositories <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">gradlePluginPortal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">google</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">mavenCentral</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\ndependencyResolutionManagement <span class=\"token punctuation\">{</span>\n    repositories <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">google</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">gradlePluginPortal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">mavenCentral</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">include</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"convention-plugins\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Here we define repositories where to find plugins and dependencies for our included build. We also declare a subproject that will contain our convention plugins.</p>\n<p><code class=\"language-text\">build.gradle</code> can be empty.</p>\n<h3>Simple convention plugin</h3>\n<p>Inside <code class=\"language-text\">build-logic/convention-plugins/build.gradle.kts</code> we need to apply <code class=\"language-text\">kotlin-dsl</code> plugin and add a depdendency on Android Gradle Plugin.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">plugins <span class=\"token punctuation\">{</span>\n    `kotlin<span class=\"token operator\">-</span>dsl`\n<span class=\"token punctuation\">}</span>\n\ndependencies <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">implementation</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"com.android.tools.build:gradle:7.0.3\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If we would like to use third-party plugins in our pre-compiled script, we must add all of them in the <code class=\"language-text\">dependencies</code> block. Here, for example, we are adding the latest Android Gradle Plugin.</p>\n<p>Then in <code class=\"language-text\">build-logic/convention-plugins/src/main/kotlin</code> we can create a convention plugin, that does some set up of AGP. The id of the plugin will be derived from file name (without extension). Let’s define <code class=\"language-text\">convention.android-app</code> plugin in <code class=\"language-text\">convention.android-app.gradle.kts</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">plugins <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">id</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"com.android.application\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nandroid <span class=\"token punctuation\">{</span>\n    defaultConfig <span class=\"token punctuation\">{</span>\n        minSdk <span class=\"token operator\">=</span> <span class=\"token number\">21</span>\n        targetSdk <span class=\"token operator\">=</span> <span class=\"token number\">31</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now any usage of <code class=\"language-text\">com.android.application</code> plugin in our project can be replaced with our convention plugin</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">plugins <span class=\"token punctuation\">{</span>\n    id <span class=\"token string\">'convention.android-app'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The convention plugin will apply Android Aplication plugin and will also set <code class=\"language-text\">defaultConfig</code> that we defined.</p>\n<h2>Resources</h2>\n<p>Before you start digging into this topic, I recommend reading the intro to <a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html#sec:precompiled_plugins\">Precompiled Script Plugins</a> from Gradle. Then explore the examples below:</p>\n<ol>\n<li><a href=\"https://docs.gradle.org/current/samples/sample_convention_plugins.html\">Convention plugins</a> – Oficial sample from Gradle.</li>\n<li><a href=\"https://github.com/dsvoronin/march-meetup-gradle\">Android Sample</a> – More realistic sample with of Android project.</li>\n<li><a href=\"https://github.com/avito-tech/avito-android/tree/develop/build-logic\">Real project usage</a></li>\n</ol>\n<p>Also, I would highly recommend reading Gradle <a href=\"https://docs.gradle.org/current/userguide/task_configuration_avoidance.html\">Task Configuration Avoidance</a> guidelines. Might be useful when writing custom plugins.</p>\n<p>Special thanks to <a href=\"https://github.com/dsvoronin\">Dmitriy Voronin</a> for inspiration and samples.</p>","fields":{"slug":"/gradle-convention-plugins","readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Refactor your Gradle build configuration with convention plugins","date":"December 10, 2021","updated":"December 11, 2021","description":"How Gradle precompiled script plugins help put your multi-module project's build logic in order.","draft":false}},"previous":{"fields":{"slug":"/effective-team-communication-in-slack"},"frontmatter":{"title":"Effective team communication in Slack"}},"next":{"fields":{"slug":"/compose-timer-implementation"},"frontmatter":{"title":"Countdown timer with Jetpack Compose"}}},"pageContext":{"id":"8b4e60c2-2e47-548e-8d3c-b215c7998e90","previousPostId":"fd5ed88e-0345-5c2f-b13f-003bd732822a"}},"staticQueryHashes":["3000541721","3274528899"]}