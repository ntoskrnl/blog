{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/blog/gradle-convention-plugins",
    "result": {"data":{"site":{"siteMetadata":{"title":"Anton Danshin's Blog"}},"markdownRemark":{"id":"8b4e60c2-2e47-548e-8d3c-b215c7998e90","excerpt":"Many Android projects contain more than one module (subproject). In a product oriented project, it will be one app module and many library modules. When the…","html":"<p>Many Android projects contain more than one module (subproject). In a product oriented project, it will be one app module and many library modules. When the team is developing white-label apps, it will be many apps on top of many library modules.</p>\n<p>Here is what I often see in our project. When creating a new module, some developers would use Android Studio GUI and then adjust it according to what they need. Others would simply copy-paste some existing module and change it. Some people would even write build configuration from scratch. Generally, there is nothing wrong with this. Bu over time, this practice had caused us several issues:</p>\n<ul>\n<li><strong>Inconsistencies.</strong> build configuration might differ from module to module (e.g., could have different <code class=\"language-text\">compileSdkVersion</code>).</li>\n<li><strong>Poor maintainability.</strong> If we need to apply some new setting to all modules, we will have to change them all.</li>\n<li><strong>Redundant logic.</strong> Build configuration may contain redundant parameters / code, developers are afraid to remove it to break something.</li>\n</ul>\n<p>Since we are making wite-labels apps, we have created a script that automates some of the copy-paste we have to do in order to bootstrap the boilerplate for new apps. The amount of duplication in the build logic grows even faster.</p>\n<h2>Sharing external dependencies and versions accross Gradle modules</h2>\n<p>One of the common things developers do, is introducing constants for external libraries. In many projects I see on Github, all versions and library locators are placed to <code class=\"language-text\">versions.gradle</code> in the project’s root directory. The file typically declares version of different libraries and plugins, and also groups all libraries by vendor Then, all the versions and dependencse are placed into Gradle’s <a href=\"https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html\">ExtraPropertiesExtension</a>, aka <code class=\"language-text\">ext</code>.</p>\n<blockquote>\n<p>I’ve heard that using <code class=\"language-text\">ext</code> to keep common parameters across subprojects is not a very good practice. I don’t know why exactly… I could certainly find some of its drawbacks if I try. However, our project is currenly using this approach.</p>\n</blockquote>\n<p>Gradle team noticed the trend and came up with a solution called <a href=\"https://docs.gradle.org/current/userguide/platforms.html\">Version Catalogs</a>, which is currently a feature preview. The feature allows you to define versions and libraries in a <code class=\"language-text\">*.toml</code> file. Gradle will generate type-safe accessors based on the declarations in the file.</p>\n<p>You could try using it for new projects. However, if you already have your own “version catalog” that works for you, I don’t really see a need to migrate to the Gradle solution. Compared to defining versions in a Gradle or Kotlin script with IDE support, I found it quite annoying that you have to edit <code class=\"language-text\">*.toml</code>. Apart from syntax highlighing, IDE doesn’t help you with the code completion (at least as of the time of writing this post there was an <a href=\"https://youtrack.jetbrains.com/issue/IDEA-262280\">open issue</a> about that), and you can easily mess it up.</p>\n<h2>Sharing common build logic accross Gradle modules</h2>\n<p>Common pattern that people do here, is either putting the code into <code class=\"language-text\">subprojects {}</code> block of root <code class=\"language-text\">build.gradle</code> file, or put configuration logic into a separate gradle file and apply it to specific module via <code class=\"language-text\">apply from: 'file.gradle'</code>.</p>\n<p>This is a solution, but because you cannot often split root <code class=\"language-text\">build.gradle</code> into separate files, the file becomes inflated. This also causes subprojects to implicitly <strong>rely</strong> on configuration logic written in the root <code class=\"language-text\">build.gradle</code>.</p>\n<p>Fortunately, now there is an easy way split the common build logic into separate gradle files (plugins) that also make subprojects explicitely declare that they are using this configuration. This approach is based on a Gradle feature <a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html#sec:precompiled_plugins\">Precompiled Script Plugins</a> and this is now a recommend way for sharing build logic accorss modules in larger projects. Such precompiled plugins that contain pieces of shared build logic are often referred to as <em>Convention plugins</em>.</p>\n<p>If you don’t have many modules, I think it still OK writing your common build logic the old way. But as project grows, you may not notice how your 10 modules became 30, and 30 become 50… So, why not invest a little bit of time and set up a future proof structure at the early?</p>\n<blockquote>\n<p>Before applying it to your project, always check whether the benefits that the convention plugins bring outweigh the drawbacks (e.g. potentially slower build or some other issue).</p>\n</blockquote>\n<p><strong>The benefits</strong> of using convention plugins are:</p>\n<ol>\n<li>Just like with <code class=\"language-text\">subprojects { }</code> configuration block, you will be able to extract common logic in one place.</li>\n<li>You will be able separate common logic into completely independent bits, which should be easier to maintain.</li>\n<li>You explicitly apply different convention plugins to different modules.</li>\n</ol>\n<blockquote>\n<p>By the way! It is possible to migrate to the new approach slowly. I am currently implementing it in our project and have only applied the plugins to a subset of modules. Seems to be working fine.</p>\n</blockquote>\n<p><strong>The drawbacks</strong> that I noticed are:</p>\n<ol>\n<li>It requires you to use newer Gradle, as well as new <code class=\"language-text\">pluginManagement {}</code>, which has some issues when used together with the older <code class=\"language-text\">builscript</code>. Ideally, all projects should migrate to new approach.</li>\n<li>It will take a little extra time to compile included build.</li>\n<li>This is not the default way, so when you introduce new team members to the project, they will have to learn your new “conventions”.</li>\n</ol>\n<h2>Resources</h2>\n<p>Before you start digging into this, I recommend reading the intro from Gradle on <a href=\"https://docs.gradle.org/current/userguide/custom_plugins.html#sec:precompiled_plugins\">Precompiled Script Plugins</a>. Then see explore the examples below.</p>\n<ol>\n<li><a href=\"https://docs.gradle.org/current/samples/sample_convention_plugins.html\">Convention plugins</a> – Oficial sample from Gradle.</li>\n<li><a href=\"https://github.com/dsvoronin/march-meetup-gradle\">Android Sample</a> – More realistic sample with of Android project.</li>\n<li><a href=\"https://github.com/avito-tech/avito-android/tree/develop/build-logic\">Real project usage</a></li>\n</ol>\n<p>Also, I would highly recommend reading Gradle <a href=\"https://docs.gradle.org/current/userguide/task_configuration_avoidance.html\">Task Configuration Avoidance</a> guidelines. Might be useful when writing custom plugins.</p>","fields":{"slug":"/gradle-convention-plugins","readingTime":{"text":"5 min read"}},"frontmatter":{"title":"Declutter your Gradle build configuration with convention plugins","date":"December 10, 2021","updated":"December 10, 2021","description":"How Gradle precompiled script plugins help put your multi-module project's build logic in order.","draft":false}},"previous":{"fields":{"slug":"/effective-team-communication-in-slack"},"frontmatter":{"title":"Effective team communication in Slack"}},"next":null},"pageContext":{"id":"8b4e60c2-2e47-548e-8d3c-b215c7998e90","previousPostId":"fd5ed88e-0345-5c2f-b13f-003bd732822a"}},
    "staticQueryHashes": ["2841359383","3274528899"]}